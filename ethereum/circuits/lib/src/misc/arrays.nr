use dep::std::{unsafe::zeroed, wrapping_add};
use crate::misc::fragment::Fragment;

pub fn alter_array<ARRAY_LEN>(array: [u8; ARRAY_LEN]) -> [u8; ARRAY_LEN] {
    let mut copy = array.map(|x| x);
    copy[0] = wrapping_add(copy[0], 1);
    copy
}

pub fn alter_fragment<MAX_LEN>(fragment: Fragment<MAX_LEN, u8>) -> Fragment<MAX_LEN, u8> {
    let mut copy = fragment;
    copy.set(0, wrapping_add(copy.at(0), 1));
    copy
}

pub fn resize<TItem, NEW_LEN, OLD_LEN>(src: [TItem; OLD_LEN]) -> [TItem; NEW_LEN] {
    assert(NEW_LEN >= OLD_LEN, "New length must be greater than or equal to old length");
    let mut dest = [zeroed(); NEW_LEN];
    for i in 0..OLD_LEN {
        dest[i] = src[i];
    }
    dest
}

pub(crate) fn memcpy_up_to_length<TItem, SRC_LEN, DEST_LEN>(dest: &mut [TItem; DEST_LEN], src: [TItem; SRC_LEN], offset: u64, length: u64) {
    assert(length <= DEST_LEN, "Destination index out of bound");
    assert(offset + length <= SRC_LEN, "Source index out of bound");
    for i in 0..DEST_LEN {
        if i < length {
            (*dest)[i] = src[offset + i];
        }
    }
}

/// Fills destination array with content of source array starting from the starting position.
///
/// # Arguments
/// * `dest` - Destination array
/// * `src` - Source array
/// * `offset` - Offset in source array 
pub(crate) fn memcpy<TItem, SRC_LEN, DEST_LEN>(dest: &mut [TItem; DEST_LEN], src: [TItem; SRC_LEN], offset: u64) {
    memcpy_up_to_length(dest, src, offset, DEST_LEN);
}

pub fn subarray_inferred_len<TItem, SRC_LEN, DEST_LEN>(src: [TItem; SRC_LEN], offset: u64) -> [TItem; DEST_LEN] {
    let mut dest = [zeroed(); DEST_LEN];
    memcpy(&mut dest, src, offset);
    dest
}

pub fn sub_array_equals_up_to_length<TItem, SUBARRAY_LEN, ARRAY_LEN>(
    subarray: [TItem; SUBARRAY_LEN],
    array: [TItem; ARRAY_LEN],
    offset: u64,
    length: u64
) -> bool where TItem: Eq {
    assert(length <= SUBARRAY_LEN, "Subarray index out of bound");
    assert(offset + length <= ARRAY_LEN, "Array index out of bound");
    let mut result = true;
    for i in 0..SUBARRAY_LEN {
        if i < length {
            result &= subarray[i] == array[offset + i];
        }
    }
    result
}

pub fn sub_array_equals<TItem, SUBARRAY_LEN, ARRAY_LEN>(
    subarray: [TItem; SUBARRAY_LEN],
    array: [TItem; ARRAY_LEN],
    offset: u64
) -> bool where TItem: Eq {
    assert(offset + SUBARRAY_LEN <= ARRAY_LEN, "Array index out of bound");
    let mut result = true;
    for i in 0..SUBARRAY_LEN {
        result &= subarray[i] == array[offset + i];
    }
    result
}
