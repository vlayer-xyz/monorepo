mod node_get_len {

    use crate::merkle_patricia_proofs::proof::get_node_len;

    #[test]
    fn success() {
        let node = [0xc2, 0x42, 0x05]; // ["0x42","0x05"]
        assert(get_node_len(node) == 3);
    }

    #[test]
    fn padded() {
        let node = [0xc2, 0x42, 0x05, 0x00]; // ["0x42","0x05"] padded
        assert(get_node_len(node) == 3);
    }

    #[test(should_fail_with="Decoded length of short list exceeds input length")]
    fn rlp_len_too_long() {
        let node = [0xc2, 0x42]; // Invalid rlp
        let _ = get_node_len(node);
    }
}

mod parity {
    use crate::merkle_patricia_proofs::proof::{EVEN, ODD, parity};

    #[test]
    fn all_parities() {
        assert(parity(0) == EVEN);
        assert(parity(1) == ODD);
        assert(parity(2) == EVEN);
        assert(parity(3) == ODD);
    }

    #[test(should_fail_with="Prefix must be 0, 1, 2 or 3")]
    fn invalid_parity() {
        let _ = parity(4);
    }
}

mod strip_prefix {

    use crate::misc::fragment::Fragment;
    use crate::merkle_patricia_proofs::proof::strip_prefix;
    use crate::misc::bytes::byte_to_nibbles;

    #[test]
        fn success_even() {
        let prefixed_key_bytes = Fragment::new_with_length(3, [0x20, 0xab, 0xcd, 0x00, 0x00, 0x00]);
        let (prefix, _) = byte_to_nibbles(prefixed_key_bytes.at(0));
        assert(prefix == 2, "Incorrect prefix");
        let stripped_nibbles = strip_prefix(prefixed_key_bytes);
        assert(
            stripped_nibbles == Fragment::new_with_length(4, [0xa, 0xb, 0xc, 0xd, 0x0, 0x0]), "Incorrect stripping of even prefix"
        );
    }

    #[test]
        fn success_odd() {
        let prefixed_key_bytes = Fragment::new_with_length(3, [0x3a, 0xbc, 0xde, 0x00, 0x00, 0x00]);
        let (prefix, _) = byte_to_nibbles(prefixed_key_bytes.at(0));
        assert(prefix == 3, "Incorrect prefix");
        let stripped_nibbles = strip_prefix(prefixed_key_bytes);
        assert(
            stripped_nibbles == Fragment::new_with_length(5, [0xa, 0xb, 0xc, 0xd, 0xe, 0x0]), "Incorrect stripping of odd prefix"
        );
    }

    #[test(should_fail_with="Expected a zero after a prefix of even parity")]
    fn non_zero_after_even_prefix() {
        let wrong_prefix = 0x21;
        let prefixed_key_bytes = Fragment::new_with_length(3, [wrong_prefix, 0xab, 0xcd, 0x00, 0x00, 0x00]);
        let _ = strip_prefix(prefixed_key_bytes);
    }

    #[test(should_fail_with="Prefix must be 0, 1, 2 or 3")]
        fn invalid_prefix() {
        let prefixed_key_bytes = Fragment::new_with_length(2, [0x4a, 0xbc, 0x00, 0x00]);
        let _ = strip_prefix(prefixed_key_bytes);
    }
}

mod extract_hash_from_branch_node {

    use crate::merkle_patricia_proofs::proof::{extract_hash_from_branch_node, MAX_NODE_FIELDS};
    use crate::rlp::decode::decode_list_of_small_strings;
    use crate::rlp::types::RlpList;
    use crate::misc::{fragment::Fragment, bytes::bytes_to_nibbles};
    use crate::fixtures::merkle_proofs::{branch_then_leaf::proof_input as branch_input};

    global key = branch_input.key;
    global branch_node = branch_input.proof.nodes[0];
    global branch_hash = Fragment::from_array([0x4d, 0xf3, 0xf1, 0x5d, 0xfc, 0x22, 0x96, 0x36, 0xc2, 0x7f, 0x5f, 0xfb, 0x66, 0x73, 0x0d, 0x90, 0x41, 0x23, 0xd3, 0xd8, 0xd6, 0xe3, 0xbc, 0xf0, 0x32, 0x5d, 0xf7, 0x1e, 0x13, 0xfb, 0xec, 0xbb]);

    #[test]
    fn branch() {
        let branch_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(branch_node));
        let key_nibbles = bytes_to_nibbles(Fragment::new(3, 1, key));
        let mut key_ptr = 0;
        assert(
            extract_hash_from_branch_node(branch_node, branch_node_rlp_list, key_nibbles, &mut key_ptr)
            == branch_hash, "Incorrect hash extracted"
        );
        assert(key_ptr == 1, "Key pointer didn't advance correctly");
    }

    #[test(should_fail_with="Expected a hash at position given by the key nibble")]
    fn fail_branch() {
        let branch_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(branch_node));
        let mut altered_key_nibbles = bytes_to_nibbles(Fragment::new(3, 1, key));
        altered_key_nibbles.set(0, 0x2);
        let mut key_ptr = 0;
        assert(
            extract_hash_from_branch_node(
            branch_node,
            branch_node_rlp_list,
            altered_key_nibbles,
            &mut key_ptr
        )
            == branch_hash, "Incorrect hash extracted"
        );
    }
}

mod extract_hash_from_extension_node {

    use crate::merkle_patricia_proofs::proof::{extract_hash_from_extension_node, MAX_NODE_FIELDS};
    use crate::rlp::decode::decode_list_of_small_strings;
    use crate::rlp::types::RlpList;
    use crate::misc::{fragment::Fragment, bytes::bytes_to_nibbles};
    use crate::fixtures::merkle_proofs::{
        branch_then_leaf::proof_input as branch_input,
        extension_odd::proof_input as extension_odd_input,
        extension_even::proof_input as extension_even_input
    };

    global extension_hash = Fragment::from_array([0x60, 0xc1, 0xdf, 0x16, 0xda, 0x26, 0x84, 0x73, 0xae, 0xe6, 0xb0, 0x02, 0xca, 0xe7, 0x9c, 0xf9, 0x10, 0xd1, 0xfa, 0x0b, 0xc8, 0xc0, 0x66, 0x9a, 0xfa, 0x63, 0x1b, 0xae, 0xd0, 0xeb, 0x6f, 0x52]);

    #[test]
    fn extension_odd() {
        let extension_node = extension_odd_input.proof.nodes[0];
        let extension_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(extension_node));
        let mut key_ptr = 0;
        let key_nibbles = bytes_to_nibbles(Fragment::new(4, 2, extension_odd_input.key));
        assert(
            extract_hash_from_extension_node(
            extension_node,
            extension_node_rlp_list,
            key_nibbles,
            &mut key_ptr
        )
            == extension_hash, "Incorrect hash extracted"
        );
        assert(key_ptr == 3, "Key pointer didn't advance correctly");
    }

    #[test]
    fn extension_even() {
        let extension_node = extension_even_input.proof.nodes[1];
        let extension_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(extension_node));
        let mut key_ptr = 1;
        let key_nibbles = bytes_to_nibbles(Fragment::new(5, 3, extension_even_input.key));
        assert(
            extract_hash_from_extension_node(
            extension_node,
            extension_node_rlp_list,
            key_nibbles,
            &mut key_ptr
        )
            == extension_hash, "Incorrect hash extracted"
        );
        assert(key_ptr == 5, "Key pointer didn't advance correctly");
    }

    #[test(should_fail_with="Extension key part does not correspond to given key nibbles")]
    fn fail_extension_not_corresponding_nibbles() {
        let extension_node = extension_even_input.proof.nodes[1];
        let extension_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(extension_node));
        let mut key_ptr = 1;
        let mut altered_key_nibbles = bytes_to_nibbles(Fragment::new(5, 3, extension_even_input.key));
        altered_key_nibbles.set(2, 0x4b);
        assert(
            extract_hash_from_extension_node(
            extension_node,
            extension_node_rlp_list,
            altered_key_nibbles,
            &mut key_ptr
        )
            == extension_hash, "Incorrect hash extracted"
        );
    }

    #[test(should_fail_with="Expected a hash at the end of the extension node")]
    fn fail_extension_without_hash() {
        let extension_node_without_hash = [
            0xc4, 0x82, 0x11, 0x23, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];
        let extension_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(extension_node_without_hash));
        let mut key_ptr = 0;
        let key_nibbles = bytes_to_nibbles(Fragment::new(4, 2, extension_odd_input.key));
        assert(
            extract_hash_from_extension_node(
            extension_node_without_hash,
            extension_node_rlp_list,
            key_nibbles,
            &mut key_ptr
        )
            == extension_hash, "Incorrect hash extracted"
        );
    }

    #[test(should_fail_with="Extension parity prefix must be 0 or 1")]
    fn fail_extension_wrong_prefix() {
        let extension_node_with_wrong_parity_prefix = [
            0xc4, 0x82, 0x31, 0x23, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];
        let extension_node_rlp_list: RlpList<MAX_NODE_FIELDS> = decode_list_of_small_strings(Fragment::from_array(extension_node_with_wrong_parity_prefix));
        let mut key_ptr = 0;
        let key_nibbles = bytes_to_nibbles(Fragment::new(4, 2, extension_odd_input.key));
        assert(
            extract_hash_from_extension_node(
            extension_node_with_wrong_parity_prefix,
            extension_node_rlp_list,
            key_nibbles,
            &mut key_ptr
        )
            == extension_hash, "Incorrect hash extracted"
        );
    }
}

mod extract_hash {

    use crate::merkle_patricia_proofs::proof::extract_hash;
    use crate::misc::{fragment::Fragment};

    #[test(should_fail_with="Invalid node type")]
    fn fail_invalid_node_type() {
        let invalid_node = [
            0xc3, 0x01, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ];
        let mut key_ptr = 0;
        let key_nibbles = Fragment::from_array([]);
        let _ = extract_hash(invalid_node, key_nibbles, &mut key_ptr);
    }
}

mod verify_node_hash {

    use crate::merkle_patricia_proofs::proof::verify_node_hash;
    use crate::fixtures::merkle_proofs::branch_then_leaf::proof_input;

    global node = proof_input.proof.nodes[0];
    global node_hash = [
            0x50, 0x7a, 0x49, 0xdf, 0x2b, 0x19, 0x39, 0x4b, 0x69, 0xa1, 0xdd, 0x55, 0x3b, 0x47, 0x4c, 0x65, 0xe1, 0xd1, 0xe6, 0x54, 0x36, 0xa2, 0x21, 0xe9, 0xc6, 0x52, 0xdb, 0x84, 0x3f, 0xf3, 0xed, 0x12
        ];

    #[test]
    fn success() {
        verify_node_hash(node, node_hash);
    }

    #[test(should_fail_with="Invalid node hash")]
    fn fail() {
        let mut invalid_node_hash = node_hash;
        invalid_node_hash[0] += 1;
        verify_node_hash(node, invalid_node_hash);
    }
}

mod verify_leaf {

    use crate::merkle_patricia_proofs::proof::verify_leaf;
    use crate::misc::{bytes::bytes_to_nibbles, fragment::Fragment};
    use crate::fixtures::merkle_proofs::branch_then_leaf::proof_input;

    global empty_key = Fragment::new_with_length(0, [0; 2]);
    global empty_value = [];
    global empty_leaf = [0xc2, 0x20, 0x80]; // ["0x20","0x"]

    global MAX_PREFIXED_KEY_NIBBLE_LEN = 6;
    global MAX_VALUE_LEN = 3;
    global some_key = [0xab, 0xcd];
    global some_key_fragment: Fragment<MAX_PREFIXED_KEY_NIBBLE_LEN, u8> = Fragment::from_array_resize(some_key);
    global some_key_nibbles = bytes_to_nibbles(some_key_fragment);
    global some_value: [u8; MAX_VALUE_LEN] = [0x00, 0x12, 0x34];
    global some_leaf = [0xc6, 0x82, 0x20, 0xcd, 0x82, 0x12, 0x34]; // ["0x20bc","0x1234"]

    #[test]
    fn success_empty() {
        verify_leaf(empty_leaf, empty_key, &mut 0, empty_value)
    }

    #[test]
    fn success_simple() {
        let mut key_ptr = 2;
        verify_leaf(some_leaf, some_key_nibbles, &mut key_ptr, some_value)
    }

    #[test]
    fn success_from_fixtures() {
        let ( key, value, leaf ) = (proof_input.key, proof_input.value, proof_input.proof.leaf);
        let key_nibbles = bytes_to_nibbles(Fragment::new(3, 1, key));
        verify_leaf(leaf, key_nibbles, &mut 1, value)
    }

    #[test(should_fail_with="Leaf expected to have 2 fields")]
    fn fail_invalid_rlp() {
        let invalid_leaf_rlp = [0xc1, 0x12]; // ["0x12"]
        verify_leaf(invalid_leaf_rlp, empty_key, &mut 0, empty_value)
    }

    #[test(should_fail_with="Leaf parity prefix must be 2 or 3")]
    fn fail_invalid_prefix() {
        let leaf_with_invalid_prefix = [0xc6, 0x82, 0x00, 0xbc, 0x82, 0x12, 0x34]; // ["0x00bc","0x1234"]
        verify_leaf(leaf_with_invalid_prefix, empty_key, &mut 0, empty_value)
    }

    #[test(should_fail_with="Key mismatch in the leaf")]
    fn fail_wrong_key() {
        let mut wrong_key_nibbles = some_key_nibbles;
        wrong_key_nibbles.set(2, 0xd);
        let mut key_ptr = 2;
        verify_leaf(some_leaf, wrong_key_nibbles, &mut key_ptr, some_value)
    }

    #[test(should_fail_with="Expected to consume all key nibbles")]
    fn fail_key_not_consumed() {
        let mut long_key_nibbles = some_key_nibbles;
        long_key_nibbles.push_back(0xd);
        let mut key_ptr = 2;
        verify_leaf(some_leaf, long_key_nibbles, &mut key_ptr, some_value)
    }

    #[test(should_fail_with="Value length mismatch")]
    fn fail_value_len_mismatch() {
        let mut key_ptr = 2;
        let long_value = [0x0, 0x12, 0x34, 0x56];
        verify_leaf(some_leaf, some_key_nibbles, &mut key_ptr, long_value)
    }

    #[test(should_fail_with="Value mismatch")]
    fn fail_value_mismatch() {
        let mut key_ptr = 2;
        let mut wrong_value = some_value;
        wrong_value[2] += 1;
        verify_leaf(some_leaf, some_key_nibbles, &mut key_ptr, wrong_value)
    }
}

mod verify_merkle_proof {

    use crate::merkle_patricia_proofs::proof::verify_merkle_proof;
    use crate::misc::arrays::alter_array;
    use crate::fixtures::mainnet::{
        homestead::fork::{
        header::receipts_root as homestead_receipts_root,
        receipt_proof::proof_input as homestead_receipt_proof_input,
        header::transactions_root as homestead_transactions_root,
        transaction_proof::proof_input as homestead_transaction_proof_input
    },
        cancun::small_block::{
        header::receipts_root as cancun_receipts_root,
        receipt_proof::proof_input as cancun_receipt_proof_input,
        header::transactions_root as cancun_transactions_root,
        transaction_proof::proof_input as cancun_transaction_proof_input
    },
        london::crypto_punks::{state_proof::proof_input as london_state_proof_input, header::state_root as london_state_root},
        paris::bored_ape_yacht_club::{state_proof::proof_input as paris_state_proof_input, header::state_root as paris_state_root},
        paris::usdc_circle::{
        storage_proof::proofs as paris_circle_storage_proof_inputs,
        account::storage_root as paris_circle_storage_root
    },
        paris::usdc_uniswap::{
        storage_proof::proofs as paris_uniswap_storage_proof_inputs,
        account::storage_root as paris_uniswap_storage_root
    }
    };
    use crate::fixtures::merkle_proofs::{
        leaf::{proof_input as leaf_proof_input, root as leaf_root},
        branch_then_leaf::{proof_input as branch_proof_input, root as branch_root},
        extension_odd::{proof_input as extension_odd_proof_input, root as extension_odd_root},
        extension_even::{proof_input as extension_even_proof_input, root as extension_even_root}
    };

    #[test]
    fn success_leaf() {
        verify_merkle_proof(
            leaf_proof_input.key,
            leaf_proof_input.value,
            leaf_root,
            leaf_proof_input.proof
        );
    }

    #[test]
    fn success_branch() {
        verify_merkle_proof(
            branch_proof_input.key,
            branch_proof_input.value,
            branch_root,
            branch_proof_input.proof
        );
    }

    #[test]
    fn success_extension_even() {
        verify_merkle_proof(
            extension_even_proof_input.key,
            extension_even_proof_input.value,
            extension_even_root,
            extension_even_proof_input.proof
        );
    }

    #[test]
    fn success_extension_odd() {
        verify_merkle_proof(
            extension_odd_proof_input.key,
            extension_odd_proof_input.value,
            extension_odd_root,
            extension_odd_proof_input.proof
        );
    }

    #[test]
    fn success_london_state() {
        verify_merkle_proof(
            london_state_proof_input.key,
            london_state_proof_input.value,
            london_state_root,
            london_state_proof_input.proof
        );
    }

    #[test]
    fn success_paris_state() {
        verify_merkle_proof(
            paris_state_proof_input.key,
            paris_state_proof_input.value,
            paris_state_root,
            paris_state_proof_input.proof
        );
    }

    #[test]
    fn success_paris_circle_storage() {
        let paris_circle_storage_proof_input = paris_circle_storage_proof_inputs[0];
        verify_merkle_proof(
            paris_circle_storage_proof_input.key,
            paris_circle_storage_proof_input.value,
            paris_circle_storage_root,
            paris_circle_storage_proof_input.proof
        );
    }

    #[test]
    fn success_paris_uniswap_storage() {
        let paris_uniswap_storage_proof_input = paris_uniswap_storage_proof_inputs[0];
        verify_merkle_proof(
            paris_uniswap_storage_proof_input.key,
            paris_uniswap_storage_proof_input.value,
            paris_uniswap_storage_root,
            paris_uniswap_storage_proof_input.proof
        );
    }

    #[test]
    fn success_homestead_receipt() {
        verify_merkle_proof(
            homestead_receipt_proof_input.key,
            homestead_receipt_proof_input.value,
            homestead_receipts_root,
            homestead_receipt_proof_input.proof
        );
    }

    #[test]
    fn success_cancun_receipt() {
        verify_merkle_proof(
            cancun_receipt_proof_input.key,
            cancun_receipt_proof_input.value,
            cancun_receipts_root,
            cancun_receipt_proof_input.proof
        );
    }

    #[test]
    fn success_homestead_transaction() {
        verify_merkle_proof(
            homestead_transaction_proof_input.key,
            homestead_transaction_proof_input.value,
            homestead_transactions_root,
            homestead_transaction_proof_input.proof
        );
    }

    #[test]
    fn success_cancun_transaction() {
        verify_merkle_proof(
            cancun_transaction_proof_input.key,
            cancun_transaction_proof_input.value,
            cancun_transactions_root,
            cancun_transaction_proof_input.proof
        );
    }

    #[test(should_fail_with="Key mismatch in the leaf")]
    fn fail_invalid_key() {
        let mut invalid_key = london_state_proof_input.key;
        invalid_key[invalid_key.len() - 1] += 1;
        verify_merkle_proof(
            invalid_key,
            london_state_proof_input.value,
            london_state_root,
            london_state_proof_input.proof
        );
    }

    #[test(should_fail_with="Value mismatch")]
    fn fail_invalid_value() {
        let mut invalid_value = london_state_proof_input.value;
        invalid_value[invalid_value.len() - 1] += 1;
        verify_merkle_proof(
            london_state_proof_input.key,
            invalid_value,
            london_state_root,
            london_state_proof_input.proof
        );
    }

    #[test(should_fail_with="Invalid node hash")]
    fn fail_invalid_root() {
        let invalid_root = alter_array(london_state_root);
        verify_merkle_proof(
            london_state_proof_input.key,
            london_state_proof_input.value,
            invalid_root,
            london_state_proof_input.proof
        );
    }

    #[test(should_fail_with="Invalid node hash")]
    fn fail_invalid_proof() {
        let mut invalid_proof = london_state_proof_input.proof;
        invalid_proof.nodes[invalid_proof.depth - 2][0] -= 1;
        verify_merkle_proof(
            london_state_proof_input.key,
            london_state_proof_input.value,
            london_state_root,
            invalid_proof
        );
    }
}
